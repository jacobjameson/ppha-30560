<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .chart-container {
        max-width: 1050px;
        margin: 0 auto;
        margin-top: 10px;
        font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
    }

    svg {
        overflow: visible;
    }

    h1 {
        margin-top: 10px;
        margin-left: 150px;
        font-family: 'Helvetica Neue';
        font-weight: 400;
        font-size: 24px;
    }

    h2 {
        margin-bottom: 30px;
        margin-left: 150px;
        font-family: 'Helvetica Neue';
        font-weight: 400;
        font-size: 15px;
    }

    .pop-up {
        position: absolute; 
        border: 1px solid black;
        border-radius: 1px;
        line-height: 1.2;
        width: 200px;
        pointer-events: none;
        background-color: white;
        padding: 10px;
        font-family: 'Helvetica Neue';
        font-size: 12px;
    }

    .source {
        max-width: 600px;
        margin-left: 150px;
        margin-top: 30px;
        font-family: 'Helvetica Neue';
        font-size: 12px;
        color: #999999;
        line-height: 1.5;

    }
    .legendTitle {
    font-size: 15px;
    font-weight: 12;
    }

    .axis path, .axis line {
    fill: none;
    stroke: none; /*black;*/
    shape-rendering: crispEdges;
    }

    .axis text {
    font-family: Consolas, 'Times New Roman', Times, serif;
    font-size: 15pt;

    }
    .links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

    table, th, td {
  border: 1px solid white;
  border-collapse: collapse;
}
th, td {
  background-color: #96D4D4;
}
    </style>
      <title>Data Viz | Jacob Jameson</title>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link href="styles.css" rel="stylesheet"></style>
      <script src="https://d3js.org/d3.v6.min.js"></script>
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
      <script src="//unpkg.com/3d-force-graph"></script>
      <script src="//code.jquery.com/jquery.js"></script>

  <body>

    <h1>
      Measuring Centrality in Social Networks: Comparison through Visualization
    </h1>

    <div id="intro">
      <h2>
        Author: Jacob Jameson
      </h2>

    <h3>

      <strong> According to Freeman in 1979: "There is certainly 
      no unanimity on exactly what centrality is or on its conceptual foundations, and 
      there is little agreement on the proper procedure for its measurement."</strong>
      <br>
      <br>
      Social network analysis can be used to measure the importance of a 
      person as a function of the social structure of a community or organization. 
      In social networks, centrality measures this kind of structural importance of the 
      node of a person. This project uses data visualization as a tool to explain how different
      measures of centrality may be used to analyze different questions in network analysis. 
      In this project we will explore the following centrality measures:
      <br>
      <ul>
        <li>Degree Centrality</li>
        <li>Eigenvector Centrality</li>
        <li>Katz Centrality</li>
        <li>PageRank</li>
        <li>HITS Hubs and Authorities</li>
        <li>Closeness Centrality</li>
        <li>Betweenness Centrality</li>
      </ul>
      <br>
      For these examples we will look at centrality for both directed and undirected graphs.
      The main difference between directed and undirected graph being that a directed graph 
      contains an ordered pair of vertices whereas an undirected graph contains an unordered pair of vertices.
      <br>
      <br>
      An example of a <strong>directed graph</strong> would be one in which people nominate their top 5 friends.
      In this graph, nodes (people) would connect to others nodes through directed edges (nominations). It is 
      possible for Jacob to nominate Kashif without Kashif nominating him back. You can imagine why centrality 
      in a friendship network might take into account the direction of these nominations. If I list 100 
      people as my friends and none of them list me back, do we think I am a popular person? 
      <br>
      <br>
      An <strong>undirected graph</strong> is one in which connectedness of two nodes does not have a direction 
      associated with it. This network may be one used in contagious diseases modeling, where centrality may be defined 
      as the number of nodes that interact with another node and the direction is irrelevant.
      <br>
      <br>
    </h3>
  </div>



  </div>

    <h2>
       <strong>Degree Centrality</strong>
    </h2>
    <h3>
    <img src="graphs/g degree centrality.svg" width="800" height=auto class='center'/>
    <br>
    Degree of a node is basically number of edges that it has. The basic intuition is that, 
    nodes with more connections are more influential and important in a network. In other words, 
    the person with higher friend count in a social network, the more cited paper (in-degree) in a 
    scientific citation network is the one that is more central according to this metric.
    <br>
    <br>
    For directed graphs, in-degree, number of incoming points, is considered as importance factor for nodes.
    <br>
    <br>
    <img src="graphs/Dig degree centrality.svg" width="800" height=auto class='center'/>
    <br>
  </h3>
  <h2>
     <strong>Eigenvector Centrality</strong>
  </h2>
  <h3>
    <img src="graphs/g eigenvector centrality.svg" width="800" height=auto class='center'/>
    <br>
    Eigenvector centrality is a basic extension of degree centrality, which defines 
    centrality of a node as proportional to its neighbors’ importance. When we sum up 
    all connections of a node, not all neighbors are equally important. Let’s consider 
    two nodes in a friend network with same degree, the one who is connected to more central 
    nodes should be more central.
    <br>
    <br>
    First, we define an initial guess for the centrality of nodes in a graph as 
    \(x_i=1\). Now we are going to iterate for the new centrality value \(x_i'\) for node i as following:
    <br>
    <br>
    $$x_i' = \sum_{j} A_{ij}x_j$$
    <br>
    <br>
    Here \(A_{ij}\) is an element of the adjacency matrix, where it gives 1 or 0 for whether an 
    edge exists between nodes \(i\) and \(j\). it can also be written in matrix notation as \(\mathbf{x'} = \mathbf{Ax}\). 
    We iterate over t steps to find the vector \(\mathbf{x}(t)\) as:
    <br>
    <br>
    $$\mathbf{x}(t) = \mathbf{A^t x}(0)$$
    <br>
    <br>
    The drawing also shows, the nodes which have the same number of connections are not necessarily in 
    the same heat map color. The one that is connected to more central nodes are more hot in this visualization.
    <br>
    <br>
    However, as we can see from the definition, it is a problematic measure for directed graphs. 
    Let’s say that a new research paper is published and it references a handful of existing papers. 
    It would not contribute to any of those referenced papers in this citation network because it is not 
    cited by any other papers and has zero eigenvector centrality. In other words, eigenvector centrality 
    would not take zero in-degree nodes into account in directed graphs such as citation networks.
    <br>
    <br>
    <img src="graphs/Dig eigenvector centrality.svg" width="800" height=auto class='center'/>
    <br>
    </h3>

</body>

<svg width=500 height=500 class=center></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

  var svg = d3.select("svg"),
      width = +svg.attr("width"),
      height = +svg.attr("height");
  
  var color = d3.scaleOrdinal(d3.schemeCategory20);
  
  var simulation = d3.forceSimulation()
      .force("link", d3.forceLink().id(function(d) { return d.id; }))
      .force("charge", d3.forceManyBody())
      .force("center", d3.forceCenter(width / 2, height / 2));
  
  d3.json("network.json", function(error, graph) {
    if (error) throw error;
  
    var link = svg.append("g")
        .attr("class", "links")
      .selectAll("line")
      .data(graph.links)
      .enter().append("line")
        .attr("stroke-width", function(d) { return Math.sqrt(d.value); });
  
    var node = svg.append("g")
        .attr("class", "nodes")
      .selectAll("circle")
      .data(graph.nodes)
      .enter().append("circle")
        .attr("r", 5)
        .attr("fill", function(d) { return color(d.group); })
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));
  
    node.append("title")
        .text(function(d) { return d.id; });
  
    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);
  
    simulation.force("link")
        .links(graph.links);
  
    function ticked() {
      link
          .attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });
  
      node
          .attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; });
    }
  });
  
  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  
  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }
  
  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
  
  </script>

<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.10.0/d3.min.js"></script>



</html>

